syntax = "proto3";

package tapp_service;

// Service definition
service TappService {
  // Start an application using Docker Compose content (async - returns task ID)
  rpc StartApp(StartAppRequest) returns (StartAppResponse);

  // Get task status for async operations
  rpc GetTaskStatus(GetTaskStatusRequest) returns (GetTaskStatusResponse);

  // List all deployed applications' measurement information
  rpc ListAppMeasurements(ListAppMeasurementsRequest)
      returns (ListAppMeasurementsResponse);

  // Get attestation evidence for external verifiers
  rpc GetEvidence(GetEvidenceRequest) returns (GetEvidenceResponse);

  // Get application-bound key from KBS based on app ID
  rpc GetAppKey(GetAppKeyRequest) returns (GetAppKeyResponse);

  // Get application secret key (private key) - local access only
  rpc GetAppSecretKey(GetAppSecretKeyRequest) returns (GetAppSecretKeyResponse);

  // Get application information
  rpc GetAppInfo(GetAppInfoRequest) returns (GetAppInfoResponse);

  // Get service status and health information
  rpc GetServiceStatus(GetServiceStatusRequest)
      returns (GetServiceStatusResponse);

  // Get service logs with filtering options
  rpc GetServiceLogs(GetServiceLogsRequest) returns (GetServiceLogsResponse);

  // Get application logs (docker compose logs)
  rpc GetAppLogs(GetAppLogsRequest) returns (GetAppLogsResponse);
}

enum LogLevel {
  DEBUG = 0;
  INFO = 1;
  WARNING = 2;
  ERROR = 3;
}

enum ServiceHealthStatus {
  HEALTHY = 0;
  UNHEALTHY = 1;
  UNKNOWN = 2;
}

// Task status for async operations
enum TaskStatus {
  PENDING = 0;    // Task is queued but not started
  RUNNING = 1;    // Task is currently running
  COMPLETED = 2;  // Task completed successfully
  FAILED = 3;     // Task failed with error
}

enum EvidenceFormat {
  RAW_QUOTE = 0;           // Raw TDX quote
  JSON_EVIDENCE = 1;       // JSON formatted evidence with metadata
  COMPOSITE_EVIDENCE = 2;  // Evidence with additional device attestations
}

// Start App Messages
message MountFile {
  string source_path = 1;  // Source path in compose file, e.g., ./nginx.conf
  bytes content = 2;       // File content (base64 encoded)
  string mode = 3;         // File permissions, e.g., "0644"
}

message StartAppRequest {
  string compose_content = 1;
  string app_id = 2;  // Application identifier for key binding
  repeated MountFile mount_files =
      3;  // Files to mount (mapped by source_path from compose volumes)
  bytes deployer = 4;  // 32 bytes deployer public key
}

message StartAppResponse {
  bool success = 1;
  string message = 2;
  string task_id = 3;   // Async task identifier for tracking progress
  int64 timestamp = 4;  // Timestamp of the start request
}

// Task Status Messages
message GetTaskStatusRequest {
  string task_id = 1;  // Task identifier to query
}

message TaskResult {
  string app_id = 1;   // Application identifier (on success)
  bytes deployer = 2;  // 32 bytes deployer public key (on success)
  string error = 3;    // Error message (on failure)
}

message GetTaskStatusResponse {
  bool success = 1;
  string message = 2;
  string task_id = 3;
  TaskStatus status = 4;  // Current task status
  TaskResult result = 5;  // Task result (only available when completed/failed)
  int64 created_at = 6;   // Task creation timestamp
  int64 updated_at = 7;   // Last update timestamp
}

// List App Measurements Messages
message ListAppMeasurementsRequest {
  // Optional filters (empty means list all)
  string deployer_filter = 1;  // Filter by deployer (hex string)
}

message AppMeasurementInfo {
  string app_id = 1;        // Application identifier (original, without suffix)
  string compose_hash = 2;  // Hash of compose file content
  string volumes_hash = 3;  // Hash of mounted volumes
  string deployer = 4;      // Deployer public key (hex)
  int64 timestamp = 5;      // Measurement timestamp
}

message ListAppMeasurementsResponse {
  bool success = 1;
  string message = 2;
  repeated AppMeasurementInfo measurements = 3;
  int32 total_count = 4;      // Total number of measurements
  string hash_algorithm = 5;  // Hash algorithm used globally (e.g., "sha256")
}

// Get Evidence Messages
message GetEvidenceRequest {
  bytes report_data =
      1;  // Custom report data (up to 64 bytes) to be included in the quote
          // Can be nonce, hash of business data, or any custom data
          // If empty, will use zero-filled 64 bytes
}

message GetEvidenceResponse {
  bool success = 1;
  string message = 2;
  bytes evidence = 3;
  // Metadata
  string tee_type = 4;  // TEE type (e.g., "TDX", "SNP", "SGX")
  int64 timestamp = 5;  // Evidence generation timestamp
}

// Get App Key Messages (replaces GetPubkey)
message GetAppKeyRequest {
  string app_id = 1;            // Application identifier
  string key_type = 2;          // Key type: "ethereum", "rsa", "ec"
  bytes additional_data = 3;    // Additional binding data
  string kbs_resource_uri = 4;  // KBS resource URI for key material
}

message GetAppKeyResponse {
  bool success = 1;
  string message = 2;

  // Key material (format depends on key_type)
  bytes public_key = 3;  // Public key bytes
  // Ethereum-specific fields (when key_type="ethereum")
  bytes eth_address = 4;  // 20-byte Ethereum address
  // Key provenance
  string key_source = 5;  // Source: "kbs", "in-memory"
}

// Get App Secret Key Messages (local access only)
message GetAppSecretKeyRequest {
  string app_id = 1;    // Application identifier
  string nonce = 2;     // Random nonce (prevents replay attacks)
  int64 timestamp = 3;  // Request timestamp (unix timestamp in seconds)
  bytes signature = 4;  // Deployer's signature over (app_id || nonce ||
                        // timestamp) Must be signed by the app's deployer
}

message GetAppSecretKeyResponse {
  bool success = 1;
  string message = 2;

  // Secret key material (SENSITIVE - only for local access)
  bytes private_key = 3;  // Private key bytes (32 bytes for Ethereum)
  bytes public_key = 4;   // Public key bytes (for verification)
  bytes eth_address = 5;  // Ethereum address (if applicable)
}

message GetAppInfoRequest {
  string app_id = 1;
}

message GetAppInfoResponse {
  bool success = 1;
  string message = 2;

  string app_id = 3;
  string compose_content = 5;
  string volumes_content = 6;
}

// Service Status Messages
message GetServiceStatusRequest {
  string service_name = 1;  // Optional: specific service name to check
}

message ServiceInfo {
  string name = 1;
  ServiceHealthStatus status = 2;
  string status_message = 3;
  int64 uptime_seconds = 4;
  int64 memory_usage_mb = 5;
  double cpu_usage_percent = 6;
  int32 pid = 7;
  string version = 8;

  // Attestation-related status
  bool attestation_available = 9;
  string tee_type = 10;
  bool kbs_connected = 11;
}

message GetServiceStatusResponse {
  bool success = 1;
  string message = 2;
  repeated ServiceInfo services = 3;
  int64 timestamp = 4;

  // Overall system status
  bool system_healthy = 5;
  string system_version = 6;
}

// Service Logs Messages
message GetServiceLogsRequest {
  string file_name = 1;  // Log file name (if empty, list all available files)
  int32 lines = 2;       // Number of lines to retrieve (default: 100, tail -n behavior)
}

message LogFileInfo {
  string file_name = 1;   // File name
  int64 size_bytes = 2;   // File size
  int64 modified_time = 3;  // Last modified timestamp
}

message GetServiceLogsResponse {
  bool success = 1;
  string message = 2;

  // If file_name is empty in request, return list of available files
  repeated LogFileInfo available_files = 3;

  // If file_name is specified, return file content
  string content = 4;       // File content (last N lines)
  int32 total_lines = 5;    // Total lines returned
}

// Application Logs Messages
message GetAppLogsRequest {
  string app_id = 1;          // Application identifier
  int32 lines = 2;            // Number of lines to retrieve (default: 100)
  string service_name = 3;    // Optional: specific service in compose (e.g., "web", "broker")
}

message GetAppLogsResponse {
  bool success = 1;
  string message = 2;
  string content = 3;         // Log content from docker compose logs
  int32 total_lines = 4;      // Total lines returned
}
